# 간단한 사칙연산 계산기 만들기
사용자로부터 입력받은 값을 기반으로 사칙연산을 수행하는 계산기 애플리케이션을 개발하는 과제입니다.

Java 문법과 객체지향 설계를 학습하기 위한 과제로, 단계적으로 기능을 확장하며 개발되었습니다.

<br>

## 개발 환경
- **Language**: Java 17
- **IDE**: IntelliJ IDEA

<br>

## 프로젝트 구조
```
src/main/java/com/example
├── lv1
│   └── Main.java
├── lv2
│   ├── App.java
│   └── Calculator.java
├── lv3
│   ├── enums
│   │   └── OperatorType.java
│   ├── App.java
│   └── ArithmeticCalculator.java
``` 

<br>

## 요구사항
### [LEVEL 1] Java의 기본 문법을 활용한 계산기 만들기
1. **입력 처리**
   - 사용자는 피연산자 2개와 연산자 1개를 입력해야 합니다.
   - 피연산자는 0 또는 양의 정수로 제한됩니다.
   - 연산자는 `+`, `-`, `*`, `/` 중 하나여야 합니다.

2. **연산 수행**
   - 입력받은 값을 기반으로 연산을 수행하고, 결과를 출력합니다.
   - 연산 중 오류가 발생한 경우(예: 0으로 나누기) 에러 메시지를 출력합니다.

3. **프로그램 실행 흐름**
   - 사용자에게 프로그램을 계속 실행할 것인지 여부를 묻습니다.
   - 사용자가 `"exit"`을 입력하면 프로그램을 종료합니다.
   - 사용자가 `"exit"`을 입력하지 않으면 1단계로 돌아갑니다.

<br>

### [LEVEL 2] 클래스를 적용한 계산기 만들기
1. **연산 수행 기능 위임**
   - 레벨 1의 연산 수행 기능을 `Calculator` 클래스에 위임합니다.

2. **연산 결과 저장**
   - `Calculator` 클래스는 연산 결과를 `Collection` 필드에 저장합니다. 

3. **Calculator 클래스 활용**
   - `Calculator` 클래스를 활용해 연산을 수행하는 로직을 작성합니다.
   - 레벨 1의 프로그램 실행 흐름을 그대로 유지합니다.

4. **필드 캡슐화**
   - `Calculator` 클래스의 필드를 캡슐화합니다.
   - 필드에 접근하기 위해 `Getter`와 `Setter`를 제공합니다.
   - `Getter`와 `Setter`를 활용하는 로직을 작성합니다.

5. **연산 결과 삭제 기능**
   - `Calculator` 클래스에 저장된 값 중 가장 먼저 저장된 값을 삭제하는 기능을 구현합니다.
   - 해당 기능을 사용하는 로직을 작성합니다.
  
<br>

### [LEVEL 3] Enum, Generic, Lambda를 적용한 계산기 만들기
1. **Enum을 사용한 연산자 타입 관리**
   - 연산자 타입을 `Enum`으로 정의하여 연산자에 대한 정보를 관리합니다.
   - `ArithmeticCalculator` 클래스에 `Enum`을 활용하여 연산자 타입을 처리합니다.

2. **Generic을 활용한 피연산자 타입 확장**
   - `ArithmeticCalculator` 클래스의 연산메서드에 `Generic`을 적용하여 다양한 타입의 피연산자를 처리할 수 있도록 확장합니다.

3. **Lambda와 Stream을 활용한 결과 필터링**
   - 저장된 연산 결과 중, 사용자가 입력한 기준 값보다 큰 값들을 조회하는 메서드를 추가합니다.
   - 이를 위해 `Lambda`와 `Stream`을 사용하여 필터링 작업을 수행합니다.

<br>

## 구현 기능
### [LEVEL 1] 기본 기능 구현
- **연산자 입력 처리**: 사용자로부터 피연산자 2개와 연산자 1개를 입력받아 처리합니다.
- **연산 수행**: `+`, `-`, `*`, `/` 연산을 처리하며, 오류 처리(예: 0으로 나누기)를 구현했습니다.
- **프로그램 흐름 제어**: 사용자 입력에 따라 프로그램을 종료하거나 반복 실행합니다.

### [LEVEL 2] 클래스 기반 계산기 구현
- **`Calculator` 클래스 생성**: 연산을 처리하고, 결과를 `Collection`에 저장하며, `Getter`와 `Setter`를 활용하여 필드를 캡슐화합니다.
- **연산 결과 삭제**: 가장 오래된 결과를 삭제하는 기능을 구현했습니다.

### [LEVEL 3] 고급 기능 구현
- **`Enum`을 활용한 연산자 처리**: 연산자 타입을 `Enum`으로 관리하여 코드의 가독성과 유지 보수성을 높였습니다.
- **`Generic`을 통한 피연산자 처리 확장**: 다양한 타입의 피연산자를 처리할 수 있도록 `Generic`을 활용하여 연산 메서드를 확장했습니다.
- **`Lambda`와 `Stream`을 사용한 결과 필터링**: 사용자가 입력한 기준 값보다 큰 연산 결과를 필터링하는 기능을 구현했습니다.

<br>

## 실행 결과
```
사칙 연산을 시작합니다.
수를 입력하세요: 8
사칙 연산 기호(+, -, *, /)를 입력하세요: *
수를 입력하세요: 12
[SUCCESS] 계산 결과: 96

계속하시겠습니까? (끝내시려면 exit을 입력하세요.): y

사칙 연산을 시작합니다.
수를 입력하세요: 4
사칙 연산 기호(+, -, *, /)를 입력하세요: -
수를 입력하세요: 10
[SUCCESS] 계산 결과: -6

계속하시겠습니까? (끝내시려면 exit을 입력하세요.): exit

입력 값보다 큰 결과 값들을 출력합니다.
수를 입력하세요: 0
96 
```

<br>

## 향후 개선사항
현재 계산기는 제네릭을 사용하여 다양한 타입의 피연산자를 처리하고 있지만, 각 타입에 따라 별도의 연산 로직을 정의하고, 분기문을 통해 타입을 검증하는 비효율적인 구조적 한계가 존재합니다. 이를 해결하기 위해, 다음과 같은 개선 방안을 고려하고 있습니다:

<br>

### 1. 산술 연산 공통 인터페이스 사용
- 산술 연산을 처리하는 공통 인터페이스를 정의하고, 각 타입별로 해당 인터페이스를 구현하여 연산을 수행하도록 개선합니다.
- 이를 통해 타입별로 분기문을 작성하지 않고도 연산을 유연하게 처리할 수 있습니다.
- 공통 인터페이스를 활용하면, 코드의 가독성과 유지보수성을 높이고, 새로운 타입의 연산을 추가할 때 유연하게 확장할 수 있습니다.

### 2. BigDecimal 사용
- `BigDecimal`은 숫자를 정밀하게 저장하고 표현할 수 있는 자료형으로, 특히 소수점 연산에서 발생할 수 있는 오차를 최소화할 수 있습니다.
- 모든 연산을 `BigDecimal`로 처리하면, 타입에 관계없이 일관된 방식으로 계산을 수행할 수 있으며, 보다 높은 정확도의 연산을 보장할 수 있습니다.

<br>

이러한 개선을 통해 계산기의 유연성과 정확도를 높이고, 다양한 타입의 연산을 보다 효율적이고 안정적으로 처리할 수 있도록 할 계획입니다.

